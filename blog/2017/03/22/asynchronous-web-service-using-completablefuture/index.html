<!doctype html><html lang=en><head><title>Asynchronous web service using CompletableFuture :: Nick Ebbitt</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Until recently I&amp;rsquo;ve not spent a lot time looking into the enhancements provided in java.util.concurrent as part of the Java 8 release. This has been predominantly due to the fact I&amp;rsquo;ve been using the Akka toolkit to handle any concurrency concerns within the Java app I&amp;rsquo;ve been working on.
The app in question uses the Spring framework and exposes a number of &amp;ldquo;RESTful&amp;rdquo; HTTP endpoints implemented using a Spring @RestController and the DeferredResult class."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://nickebbitt.com/blog/2017/03/22/asynchronous-web-service-using-completablefuture/><link rel=stylesheet href=https://nickebbitt.com/styles.css><link rel="shortcut icon" href=https://nickebbitt.com/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://nickebbitt.com/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content="nickebbitt"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Asynchronous web service using CompletableFuture"><meta property="og:description" content="Until recently I&amp;rsquo;ve not spent a lot time looking into the enhancements provided in java.util.concurrent as part of the Java 8 release. This has been predominantly due to the fact I&amp;rsquo;ve been using the Akka toolkit to handle any concurrency concerns within the Java app I&amp;rsquo;ve been working on.
The app in question uses the Spring framework and exposes a number of &amp;ldquo;RESTful&amp;rdquo; HTTP endpoints implemented using a Spring @RestController and the DeferredResult class."><meta property="og:url" content="https://nickebbitt.com/blog/2017/03/22/asynchronous-web-service-using-completablefuture/"><meta property="og:site_name" content="Nick Ebbitt"><meta property="og:image" content="https://nickebbitt.com/img/favicon/orange.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2017-03-22 00:00:00 +0000 UTC"></head><body class=orange><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/posts><div class=logo>Nick Ebbitt</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/contact>Contact</a></li><li><a href=/posts>Posts</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/contact>Contact</a></li><li><a href=/posts>Posts</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://nickebbitt.com/blog/2017/03/22/asynchronous-web-service-using-completablefuture/>Asynchronous web service using CompletableFuture</a></h1><div class=post-meta><time class=post-date>2017-03-22 ::</time></div><div class=post-content><div><p>Until recently I&rsquo;ve not spent a lot time looking into the enhancements provided in
<code>java.util.concurrent</code> as part of the Java 8 release. This has been predominantly due to
the fact I&rsquo;ve been using the <a href=http://akka.io/>Akka</a> toolkit to handle any concurrency
concerns within the Java app I&rsquo;ve been working on.</p><p>The app in question uses the <a href=https://projects.spring.io/spring-framework/>Spring framework</a> and exposes a number of &ldquo;RESTful&rdquo; HTTP endpoints implemented using a Spring <a href=https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html><code>@RestController</code></a> and the <a href=https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html><code>DeferredResult</code></a> class. This provides a simple way to create an asynchronous service where a request can be handled concurrently on a thread of implementers choice. In our case things then get slightly more complicated as, rather than submit the request to a thread pool or the like for processing, we forward the <code>DeferredResult</code> to an actor. A result is provided for the <code>DeferredResult</code> at some point in the future by an actor that uses a thread managed by the actor system.</p><p>This approach works fine but the level of complexity in the implementation isn&rsquo;t desirable for a couple of reasons. One is that the bridge into the actor system makes it more difficult to test. There is also the additional maintenance overhead caused by the code being more difficult to understand and reason about at the seams between the actor/non-actor code.</p><p>Then I saw the following tweet (since removed) from Jamie Allen (former employee of <a href=https://www.lightbend.com/>Lightbend</a>, stewards of Akka)&mldr;</p><blockquote><p>Really, if you’re using Akka purely for simpler local concurrency, you’re doing it wrong. That’s for Futures; much more composable.</p></blockquote><p>&mldr;and it got me thinking more about the approach we had used and whether the standard concurrency utilities available in Java could provide a much simpler alternative to our current design based on <code>DeferredResult</code> and Akka.</p><h3 id=a-bit-about-completablefuture>A bit about CompletableFuture<a href=#a-bit-about-completablefuture class=hanchor arialabel=Anchor>&#8983;</a></h3><p>One of the enhancements to the standard concurrency utilities that arrived in Java 8 comes in the form of the
<a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html><code>CompletableFuture</code></a>
class. <code>CompletableFuture</code> implements the <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html><code>Future</code></a>
interface (available since Java 5) that provides the result of an asynchronous computation. It also implements the <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html><code>CompletionStage</code></a>
interface that defines the contract for &ldquo;&mldr;a stage of possibly asynchronous computation, that
performs an action or computes a value when another <code>CompletionStage</code> completes.&rdquo;</p><blockquote><p>In short, the <code>CompletableFuture</code> class provides us with a way to compose, combine and execute
asynchronous computation steps.</p></blockquote><p>I&rsquo;m not going to go into detail about <code>CompletableFuture</code> however the following video from Tomasz Nurkiewicz provides a great primer for understanding what it offers.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/-MBPQ7NIL_Y style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><p>What I&rsquo;m specifically interested in is how we can use <code>CompletableFuture</code> in combination with a Spring <a href=https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html><code>@RestController</code></a> to implement HTTP endpoints that handle requests asynchronously.</p><p>Given a method that simulates some time consuming computation&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> String <span style=color:#a6e22e>processRequest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Start processing request&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>sleep</span><span style=color:#f92672>(</span><span style=color:#ae81ff>5000</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InterruptedException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Completed processing request&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> RESULT<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>&mldr;the following examples demonstrate a few different approaches to handling requests.</p><h3 id=a-synchronous-example>A synchronous example<a href=#a-synchronous-example class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Here we have a HTTP endpoint that the handles a request synchronously.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span><span style=color:#f92672>(</span>path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/sync&#34;</span><span style=color:#f92672>,</span> method <span style=color:#f92672>=</span> RequestMethod<span style=color:#f92672>.</span><span style=color:#a6e22e>GET</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getValueSync</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Request received&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> processRequest<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>This generates the following log output&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>21:21:19.204 <span style=color:#f92672>[</span> main<span style=color:#f92672>]</span> Before request
</span></span><span style=display:flex><span>21:21:19.347 <span style=color:#f92672>[</span>http-nio-auto-1-exec-1<span style=color:#f92672>]</span> Request received
</span></span><span style=display:flex><span>21:21:19.347 <span style=color:#f92672>[</span>http-nio-auto-1-exec-1<span style=color:#f92672>]</span> Start processing request
</span></span><span style=display:flex><span>21:21:24.351 <span style=color:#f92672>[</span>http-nio-auto-1-exec-1<span style=color:#f92672>]</span> Completed processing request
</span></span><span style=display:flex><span>21:21:24.374 <span style=color:#f92672>[</span> main<span style=color:#f92672>]</span> After request
</span></span></code></pre></div><p>The key thing to note here is that all processing occurs on the same HTTP thread (<code>http-nio-auto-1-exec-1</code>). This means that for the duration of the request the HTTP thread is blocked and unavailable to serve other requests made to the system. This is undesirable due to the potential for the servlet container&rsquo;s thread pool to be exhausted when an app is under heavy load thus impacting an apps scalability.</p><h3 id=an-asynchronous-example-using-deferredresult>An asynchronous example using DeferredResult<a href=#an-asynchronous-example-using-deferredresult class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Here we have a HTTP endpoint that handles a request asynchronously via Spring&rsquo;s <code>DeferredResult</code>. As mentioned earlier, this has been my go to approach for implementing asynchronous behaviour in a RESTful HTTP service.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span><span style=color:#f92672>(</span>path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/asyncDeferred&#34;</span><span style=color:#f92672>,</span> method <span style=color:#f92672>=</span> RequestMethod<span style=color:#f92672>.</span><span style=color:#a6e22e>GET</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> DeferredResult<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getValueAsyncUsingDeferredResult</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Request received&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    DeferredResult<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> deferredResult <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DeferredResult<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ForkJoinPool<span style=color:#f92672>.</span><span style=color:#a6e22e>commonPool</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> deferredResult<span style=color:#f92672>.</span><span style=color:#a6e22e>setResult</span><span style=color:#f92672>(</span>processRequest<span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Servlet thread released&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> deferredResult<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>This generates the following log output&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>21:21:24.418 <span style=color:#f92672>[</span> main<span style=color:#f92672>]</span> Before request
</span></span><span style=display:flex><span>21:21:24.421 <span style=color:#f92672>[</span>http-nio-auto-1-exec-2<span style=color:#f92672>]</span> Request received
</span></span><span style=display:flex><span>21:21:24.427 <span style=color:#f92672>[</span>http-nio-auto-1-exec-2<span style=color:#f92672>]</span> Servlet thread released
</span></span><span style=display:flex><span>21:21:24.427 <span style=color:#f92672>[</span>ForkJoinPool.commonPool-worker-1<span style=color:#f92672>]</span> Start processing request
</span></span><span style=display:flex><span>21:21:29.429 <span style=color:#f92672>[</span>ForkJoinPool.commonPool-worker-1<span style=color:#f92672>]</span> Completed processing request
</span></span><span style=display:flex><span>21:21:29.448 <span style=color:#f92672>[</span> main<span style=color:#f92672>]</span> After request
</span></span></code></pre></div><p>The key difference to note here is that, unlike the synchronous endpoint, the request processing occurs on a different thread (<code>ForkJoinPool.commonPool-worker-1</code>). The HTTP thread (<code>http-nio-auto-1-exec-2</code>) is released pretty much immediately making it available to serve additional requests. The actual request processing is performed at some later point in time on a different thread. For demonstration purposes I&rsquo;ve use the standard <a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html><code>ForkJoinPool</code></a> thread pool however in practice you would likely create and configure a suitable thread pool based on your use-case.</p><h3 id=an-asynchronous-example-using-completablefuture>An asynchronous example using CompletableFuture<a href=#an-asynchronous-example-using-completablefuture class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Finally we have a HTTP endpoint that handles a request asynchronously using Java 8&rsquo;s <code>CompletableFuture</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span><span style=color:#f92672>(</span>path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/asyncCompletable&#34;</span><span style=color:#f92672>,</span> method <span style=color:#f92672>=</span> RequestMethod<span style=color:#f92672>.</span><span style=color:#a6e22e>GET</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getValueAsyncUsingCompletableFuture</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Request received&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> completableFuture <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>CompletableFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>supplyAsync</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>processRequest<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Servlet thread released&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> completableFuture<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>This generates the following log output&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>21:21:29.453 <span style=color:#f92672>[</span> main<span style=color:#f92672>]</span> Before request
</span></span><span style=display:flex><span>21:21:29.456 <span style=color:#f92672>[</span>http-nio-auto-1-exec-4<span style=color:#f92672>]</span> Request received
</span></span><span style=display:flex><span>21:21:29.458 <span style=color:#f92672>[</span>http-nio-auto-1-exec-4<span style=color:#f92672>]</span> Servlet thread released
</span></span><span style=display:flex><span>21:21:29.458 <span style=color:#f92672>[</span>ForkJoinPool.commonPool-worker-1<span style=color:#f92672>]</span> Start processing request
</span></span><span style=display:flex><span>21:21:34.463 <span style=color:#f92672>[</span>ForkJoinPool.commonPool-worker-1<span style=color:#f92672>]</span> Completed processing request
</span></span><span style=display:flex><span>21:21:34.468 <span style=color:#f92672>[</span> main<span style=color:#f92672>]</span> After request
</span></span></code></pre></div><p>The result is pretty much identical to the <code>DeferredResult</code> example in that the request processing occurs on a different thread. It&rsquo;s worth noting that this example also uses the <code>ForkJoinPool</code> due it being the default when no explicit thread pool is provided to the <code>supplyAsync</code> method.</p><p><code>CompletableFuture</code> has the advantage over <code>DeferredResult</code> due to the various composable methods that it provides. This allows for more complex chains of processing to be defined that are completely asynchronous.</p><p>The following example shows a simple chain of asynchronous processing&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span><span style=color:#f92672>(</span>path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/asyncCompletableComposed&#34;</span><span style=color:#f92672>,</span> method <span style=color:#f92672>=</span> RequestMethod<span style=color:#f92672>.</span><span style=color:#a6e22e>GET</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getValueAsyncUsingCompletableFutureComposed</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> CompletableFuture
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>supplyAsync</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>processRequest<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>thenApplyAsync</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>::</span>reverseString<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=in-summary>In summary<a href=#in-summary class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The examples in this post demonstrate a couple of different approaches to creating an asynchronous HTTP endpoint.</p><p>The simplicity of <code>CompletableFuture</code> makes it a no-brainer to use in place of <code>DeferredResult</code> due to the additional power and flexibility that comes with it.</p><p>The next step to investigate further how <code>CompletableFuture</code> can integrate with, if not replace, some of the actor based functionality currently in use.</p><hr><p>All code from this post is available in <a href=https://github.com/nickebbitt/rest-async-completable-future>GitHub</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://nickebbitt.com/blog/2017/04/16/looking-forward-to-junit-5/><span class=button__icon>←</span>
<span class=button__text>Looking forward to JUnit 5</span></a></span>
<span class="button next"><a href=https://nickebbitt.com/blog/2017/02/13/tdd-sudoku-and-a-mob/><span class=button__text>TDD, Sudoku and a mob!</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>